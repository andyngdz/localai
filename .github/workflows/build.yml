# Workflow name
name: Code Quality

# Triggers for the workflow
on:
  # Run on pull requests targeting specific branches and paths
  pull_request:
    branches: [main, master, staging, develop]
    paths:
      - "**/*.ts"
      - "**/*.tsx"
      - "**/*.js"
      - "**/*.jsx"
      - "**/*.json"
      - "package.json"
      - "vitest.config.ts"
      - "test/**/*.ts"
      - ".github/workflows/code-quality.yml"
  # Run on pushes to specific branches affecting specific paths
  push:
    branches: [main, master, staging, develop]
    paths:
      - "**/*.ts"
      - "**/*.tsx"
      - "**/*.js"
      - "**/*.jsx"
      - "**/*.json"
      - "package.json"
      - "vitest.config.ts"
      - "test/**/*.ts"
      - ".github/workflows/code-quality.yml"

# Permissions required by the workflow
permissions:
  contents: read # To checkout the repository
  pull-requests: write # To comment on pull requests

# Define the jobs to be executed
jobs:
  lint-and-format:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout Code
        uses: actions/checkout@v4 # Use latest checkout action

      # Step 2: Setup Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v4 # Use latest setup-node action
        with:
          node-version: "latest"
          cache: "npm" # Enable caching for npm dependencies

      # Step 3: Install dependencies (will use cache if available)
      - name: Install dependencies
        run: npm ci # Use 'ci' for clean installs in CI environments

      # Step 4: Run Prettier format check
      - name: Check Prettier formatting
        id: format
        run: npm run ci:format
        continue-on-error: true # Allow workflow to continue even if this step fails

      # Step 5: Run ESLint check
      - name: Check ESLint
        id: lint
        run: npm run ci:lint
        continue-on-error: true # Allow workflow to continue even if this step fails

      # Step 6: Upload ESLint report artifact (only if lint step ran)
      - name: Upload ESLint Results
        if: steps.lint.outcome != 'skipped'
        uses: actions/upload-artifact@v4
        with:
          name: eslint-report.json # Name of the artifact
          path: eslint-report.json # Path to the file to upload
          retention-days: 7 # Keep artifact for 7 days

      # Step 7: Report results as a PR comment
      - name: Report Results
        # Always run this step to report status, even if previous steps failed
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7 # Use latest github-script action
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const lintStatus = "${{ steps.lint.outcome }}" === "success" ? "‚úÖ" : "‚ùå";
            const formatStatus = "${{ steps.format.outcome }}" === "success" ? "‚úÖ" : "‚ùå";
            const issue_number = context.issue.number;
            const repoInfo = { owner: context.repo.owner, repo: context.repo.repo };

            if (!issue_number) {
              console.log('Not a pull request, skipping comment.');
              return;
            }

            const body = `## Code Quality Check Results

            | Check    | Status     |
            | :------- | :--------- |
            | ESLint   | ${lintStatus}   |
            | Prettier | ${formatStatus} |

            ${lintStatus === "‚ùå" || formatStatus === "‚ùå" ?
              "‚ö†Ô∏è Please fix the code quality issues before merging this PR." :
              "‚ú® All code quality checks passed!"}`;

            try {
              await github.rest.issues.createComment({
                ...repoInfo,
                issue_number,
                body
              });
            } catch (error) {
              console.error(`Failed to create comment: ${error.message}`);
              // Optionally fail the job if commenting fails critically
              // core.setFailed(`Failed to create comment: ${error.message}`);
            }

            // Fail the job if lint or format checks failed
            if (lintStatus === "‚ùå" || formatStatus === "‚ùå") {
              core.setFailed("Code quality checks failed. See the report comment for details.");
            }

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout the repository code
      - name: Checkout Code
        uses: actions/checkout@v4

      # Step 2: Setup Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm" # Enable caching for npm dependencies

      # Step 3: Install dependencies (will use cache if available)
      - name: Install dependencies
        run: npm ci

      # Step 4: Run unit tests
      # Combine test and coverage to avoid running tests twice
      - name: Run tests with coverage
        id: test_coverage # Changed id to avoid conflict with job name
        run: npm run test:coverage # This script runs tests AND generates coverage

      # Step 5: Upload coverage report artifact
      - name: Upload coverage reports
        # Only upload if the test/coverage step succeeded
        if: steps.test_coverage.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report # Name of the artifact
          path: coverage # Path to the coverage directory
          retention-days: 7 # Keep artifact for 7 days

      # Step 6: Report test results as a PR comment
      - name: Report test results
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const testStatus = "${{ job.status }}" === "success" ? "‚úÖ" : "‚ùå";
            const coverageStatus = "${{ steps.test_coverage.outcome }}" === "success" ? "‚úÖ" : "‚ùå";

            // Read and parse the coverage HTML report
            const fs = require('fs/promises');
            let coverageData = {
              statements: "0%",
              branches: "0%",
              functions: "0%",
              lines: "0%"
            };

            try {
              const htmlContent = await fs.readFile('coverage/index.html', 'utf8');

              // Extract coverage statistics using regex
              const statementsMatch = htmlContent.match(/<span class="strong">(\d+\.\d+)% <\/span>\s*<span class="quiet">Statements<\/span>/);
              const branchesMatch = htmlContent.match(/<span class="strong">(\d+\.\d+)% <\/span>\s*<span class="quiet">Branches<\/span>/);
              const functionsMatch = htmlContent.match(/<span class="strong">(\d+\.\d+)% <\/span>\s*<span class="quiet">Functions<\/span>/);
              const linesMatch = htmlContent.match(/<span class="strong">(\d+\.\d+)% <\/span>\s*<span class="quiet">Lines<\/span>/);

              coverageData = {
                statements: statementsMatch ? `${statementsMatch[1]}%` : "0%",
                branches: branchesMatch ? `${branchesMatch[1]}%` : "0%",
                functions: functionsMatch ? `${functionsMatch[1]}%` : "0%",
                lines: linesMatch ? `${linesMatch[1]}%` : "0%"
              };

              // Debug logging
              console.log('Extracted coverage data:', coverageData);
            } catch (error) {
              console.error('Error reading coverage HTML report:', error);
              console.error('Error details:', error.message);
            }

            let body = `## Test Results

            | Test Suite | Status |
            | ---------- | ------ |
            | Unit Tests | ${testStatus} |
            | Coverage Report | ${coverageStatus} |

            ### Coverage Statistics
            | Category    | Coverage |
            |------------|----------|
            | Statements | ${coverageData.statements} |
            | Branches   | ${coverageData.branches} |
            | Functions  | ${coverageData.functions} |
            | Lines      | ${coverageData.lines} |

            ${testStatus === "‚ùå" ?
              "‚ö†Ô∏è Tests have failed. Please check the logs for details." :
              "‚úÖ All tests passed successfully!"}

            ${coverageStatus === "‚ùå" ?
              "‚ö†Ô∏è Coverage report generation failed. Please check the logs for details." :
              "üìä Coverage report has been generated and uploaded as an artifact."}`;

            // Only add this comment on PRs
            if (context.eventName === 'pull_request') {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              });
            }

            if (testStatus === "‚ùå") {
              core.setFailed("Tests failed");
            }
  sonarqube:
    name: SonarQube Analysis
    # Run after linting and testing complete, even if they failed (to analyze available reports)
    needs: [lint-and-format, test]
    # 'if: always()' ensures this job runs even if dependencies fail
    # This allows SonarQube to analyze partial results (e.g., lint passes, tests fail)
    if: always()
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout code with full history for SonarQube analysis
      - name: Checkout Code (Full History)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches all history for accurate SCM analysis

      # Step 2: Download ESLint report artifact (if available)
      - name: Download ESLint Report
        uses: actions/download-artifact@v4
        with:
          name: eslint-report.json
          path: . # Download to the current directory
        # Continue even if the artifact doesn't exist (e.g., lint job failed early)
        continue-on-error: true

      # Step 3: Download Coverage report artifact (if available)
      - name: Download Coverage Report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: coverage # Download to the 'coverage' directory
        # Continue even if the artifact doesn't exist (e.g., test job failed early)
        continue-on-error: true

      # Step 4: Run SonarQube Scan
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@master # Use master for latest updates or pin to a specific version
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
